---
title: Classes

layout: page
---

# Environment
The environment this program will be run in. Currently planned environments: physical, and virtual. `Environment` should contain implementations of `Motor`, `BumpSensor` and `DistanceSensor` appropriate to the environment. To store state in the environment, put references in the `Motor`, `BumpSensor` and `DistanceSensor` classes. The classes should contain a simple creation DSL, as discussed in the last post:

{% highlight ruby %}
DistanceSensor.new do
  on_pin number
  at_angle theta
end
{% endhighlight %}

## Motor
Represents a drive motor. Stores pin number and can turn the motor.

## BumpSensor
Represents a bump sensor. Stores pin number and contains predicate for if it detects anything.

## DistanceSensor
Represents an ultrasonic sensor. Stores pin number and can read the current distance from the sensor.

# Logger
A wrapper around a hash of arrays of IO streams for logging information. The hash takes the form

{% highlight ruby %}
{ standard: [File.new('log.txt', 'w'), STDOUT], warning: [STDERR] }
{% endhighlight %}

where the keys are different types of things to be logged, and the values are the locations that type of information to be logged to. This class then provides a logging method, invoked like so

{% highlight ruby %}
logger.log(:type, 'message')
{% endhighlight %}

# Algorithm
A wrapper around two hashes of lambdas for describing the `Robot`'s complex behaviour. One hash is for hooks. The keys of the hash are the triggers, when the code should be run by `Robot`, and the values are the code to run. The other contains non-hooked routines. The keys are names and the values are the code to run. This class could use `Method` objects instead. This class provides a DSL that looks something like this:

{% highlight ruby %}
Algorithm.new do
  define :choose_route do |destination|
    # A* search algorithm
  end

  when :hit_wall do |sensor|
    2.times { turn_left(Math::PI / 2) }
    go_forwards 10
    full_scan
    choose_route destination
  end
end
{% endhighlight %}

This translates into

{% highlight ruby %}
{ choose_route: lambda { |destination|
    # A* search algorithm
  } }
{% endhighlight %}

and

{% highlight ruby %}
{ hit_wall: lambda {
    2.times { turn_left(Math::PI / 2) }
    go_forwards 10
    full_scan
    choose_route destination
  } }
{% endhighlight %}

# Robot
Main "God" class. Its constructor takes an `Environment` object, a 'Logger' object and an `Algorithm` object. Should have a creation DSL similar to that I discussed in the last post:

{% highlight ruby %}
Robot.new(environment, algorithm, logger) do
  has_a :distance_sensor do
    on_pin pin
    at_angle theta
  end
end
{% endhighlight %}

# Folder Structure

    |-- source
    |   |-- robot.rb
    |   |-- environment.rb
    |   |-- algorith.rb
    |   |-- logger.rb
    |-- test
    |   |-- robot.rb
    |   |-- environment.rb
    |   |-- algorith.rb
    |   |-- logger.rb
    |-- program
    |   |-- environment
    |   |   |-- physical
    |   |   |   |-- environment.rb
    |   |   |   |-- motor.rb
    |   |   |   |-- bump_sensor.rb
    |   |   |   |-- distance_sensor.rb
    |   |   |-- virtual
    |   |   |   |-- environment.rb
    |   |   |   |-- motor.rb
    |   |   |   |-- bump_sensor.rb
    |   |   |   |-- distance_sensor.rb
    |   |-- algorithm
    |   |   |-- maze
    |   |   |-- rc
    |   |-- logger
    |   |   |-- console.rb
    |   |   |-- computer.rb
    |   |   |-- everywhere.rb
